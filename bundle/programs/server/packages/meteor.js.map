{"version":3,"file":"/packages/meteor.js","sources":["meteor/server_environment.js","meteor/helpers.js","meteor/setimmediate.js","meteor/timers.js","meteor/errors.js","meteor/fiber_helpers.js","meteor/startup_server.js","meteor/debug.js","meteor/dynamics_nodejs.js","meteor/url_server.js","meteor/url_common.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,U;AACA,kB;AACA,gB;AACA,E;;AAEA,qB;AACA,kC;AACA,O;AACA,8D;AACA,e;AACA,mD;AACA,G;AACA,C;AACA,2C;AACA,gD;AACA,oD;AACA,qE;AACA,C;;;;;;;;;;;;;;;;;;;ACjBA,oB;AACA,4C;;AAEA,oD;AACA,4C;AACA,2D;;AAEA,iE;AACA,uB;;AAEA,kB;AACA,mE;AACA,2B;AACA,I;AACA,yC;AACA,gD;AACA,iC;AACA,yB;AACA,8B;AACA,K;AACA,e;AACA,I;;AAEA,qE;AACA,6D;AACA,I;AACA,4C;AACA,gD;AACA,6B;AACA,wB;AACA,sB;AACA,qB;AACA,K;;AAEA,e;AACA,I;;AAEA,mE;AACA,kD;AACA,I;AACA,4C;AACA,sB;AACA,oB;AACA,oD;AACA,6B;AACA,0B;AACA,qB;AACA,c;AACA,O;AACA,qB;AACA,kC;AACA,c;AACA,sB;AACA,K;;AAEA,iD;AACA,+B;;AAEA,e;AACA,qB;AACA,U;AACA,wC;AACA,4C;;AAEA,2B;AACA,K;AACA,I;;AAEA,8E;AACA,gF;AACA,mC;AACA,4C;AACA,iD;AACA,+E;AACA,wE;AACA,I;AACA,6B;AACA,uC;AACA,sB;AACA,mB;AACA,c;AACA,yC;;AAEA,mC;AACA,gB;AACA,yE;AACA,sD;AACA,Q;;AAEA,iD;AACA,kC;AACA,mE;AACA,sB;AACA,O;AACA,4E;AACA,gD;AACA,+B;AACA,4D;AACA,iC;AACA,c;AACA,8B;AACA,4B;AACA,gB;AACA,6B;AACA,oC;AACA,S;AACA,O;AACA,6D;AACA,2C;AACA,c;AACA,0B;AACA,oB;AACA,M;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AClHA,qD;AACA,E;AACA,2C;AACA,E;AACA,gC;AACA,E;AACA,2B;AACA,E;AACA,6C;AACA,qD;AACA,E;AACA,mE;AACA,iD;AACA,E;AACA,oE;AACA,wD;AACA,mB;AACA,E;AACA,kE;AACA,6D;AACA,sE;AACA,uE;AACA,qE;AACA,mE;AACA,iE;AACA,4C;AACA,E;AACA,gE;AACA,0D;;AAEA,a;;AAEA,kB;;;AAGA,qB;;AAEA,4B;AACA,4B;AACA,gB;AACA,Q;AACA,sC;AACA,8B;AACA,M;AACA,iD;AACA,wB;AACA,G;AACA,C;;;AAGA,iE;;AAEA,2B;AACA,kE;AACA,oD;AACA,kE;AACA,oC;;AAEA,oD;AACA,gB;AACA,G;;AAEA,oD;;AAEA,uC;AACA,sC;AACA,kC;AACA,wC;AACA,I;AACA,8B;AACA,kC;;AAEA,kC;AACA,gB;;AAEA,oB;AACA,iB;;AAEA,uE;AACA,8D;AACA,mG;;AAEA,8B;AACA,qE;;AAEA,yD;AACA,yC;AACA,yE;AACA,G;;AAEA,mC;AACA,6D;AACA,oE;AACA,kE;AACA,yD;AACA,mD;AACA,kC;AACA,4D;AACA,8D;AACA,W;AACA,yB;AACA,yB;AACA,O;AACA,e;AACA,4B;AACA,O;AACA,K;AACA,G;;AAEA,gC;AACA,+D;AACA,U;AACA,qD;AACA,G;;AAEA,oC;AACA,iE;AACA,2D;AACA,sC;AACA,gB;AACA,0B;AACA,wD;AACA,I;AACA,8C;AACA,sB;AACA,C;;;AAGA,uB;AACA,oC;AACA,6B;AACA,I;AACA,6C;AACA,sB;AACA,C;;;AAGA,sB;AACA,sB;AACA,qB;AACA,e;;;;;;;;;;;;;;;;;;;AC5IA,sC;AACA,yB;AACA,qE;AACA,0E;AACA,6D;AACA,kE;AACA,G;AACA,M;AACA,a;AACA,E;;AAEA,0C;AACA,oE;AACA,yD;AACA,iE;AACA,K;AACA,E;;AAEA,kB;AACA,iE;AACA,qE;AACA,iE;;AAEA,sC;AACA,wE;AACA,I;;AAEA,uC;AACA,0E;AACA,I;;AAEA,8B;AACA,4B;AACA,I;;AAEA,6B;AACA,2B;AACA,I;;AAEA,2E;AACA,yE;AACA,0C;AACA,wE;AACA,uB;AACA,4D;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC9CA,gE;AACA,yC;AACA,2B;AACA,mC;AACA,4B;AACA,sC;AACA,E;;AAEA,wE;AACA,8E;AACA,wE;AACA,E;AACA,qD;AACA,6C;AACA,oB;;AAEA,yE;AACA,kC;AACA,6C;AACA,gD;AACA,Y;AACA,gB;AACA,wB;AACA,yC;AACA,kC;AACA,iB;AACA,K;AACA,8B;;AAEA,uC;;AAEA,0B;;AAEA,gB;AACA,I;;AAEA,8B;;AAEA,oB;AACA,E;;AAEA,qE;AACA,sE;AACA,gE;AACA,6D;AACA,E;AACA,+E;AACA,4D;AACA,8E;AACA,uE;AACA,mC;AACA,E;AACA,oC;AACA,iB;AACA,qC;AACA,oB;;AAEA,oE;AACA,kD;AACA,uB;;AAEA,iE;AACA,wE;AACA,+B;AACA,yB;;AAEA,gE;AACA,sE;AACA,uE;AACA,oE;AACA,sE;AACA,qC;AACA,2B;;AAEA,uE;AACA,wE;AACA,oB;AACA,2D;AACA,Q;AACA,4C;AACA,K;;;;;;;;;;;;;;;;;;;AChFA,+B;AACA,kC;AACA,wD;;AAEA,wC;AACA,gF;AACA,6E;AACA,sD;AACA,+B;AACA,6B;AACA,oE;AACA,I;AACA,6B;AACA,O;AACA,e;AACA,a;AACA,6B;AACA,8B;AACA,G;AACA,E;;AAEA,0E;AACA,sE;AACA,yB;AACA,E;AACA,sB;AACA,kE;AACA,mE;AACA,sC;AACA,E;AACA,0E;AACA,+C;AACA,E;AACA,oE;AACA,yC;AACA,oE;AACA,oD;AACA,E;AACA,wC;AACA,kB;AACA,+E;AACA,gF;AACA,gF;AACA,4B;AACA,yB;AACA,8E;AACA,gB;AACA,sC;AACA,6E;AACA,4E;AACA,6D;AACA,qC;AACA,+E;AACA,6E;AACA,8E;AACA,4C;AACA,yB;AACA,E;;AAEA,8C;AACA,4B;AACA,oB;;AAEA,gC;AACA,wB;AACA,6E;AACA,U;AACA,4D;AACA,K;;AAEA,yB;AACA,6E;AACA,6D;AACA,c;AACA,sB;AACA,wB;AACA,8E;AACA,oB;AACA,e;AACA,I;AACA,8B;AACA,oB;AACA,yC;AACA,wB;AACA,wB;AACA,I;;AAEA,sB;AACA,oB;AACA,iC;AACA,I;;AAEA,8B;AACA,oB;AACA,qE;AACA,I;;AAEA,sB;AACA,oB;AACA,uB;AACA,a;AACA,8B;AACA,a;AACA,0B;AACA,2C;AACA,mB;AACA,K;AACA,2B;AACA,I;;AAEA,6B;AACA,oB;;AAEA,gD;AACA,oC;AACA,a;;AAEA,uC;;AAEA,kC;AACA,yB;AACA,oB;AACA,e;AACA,O;AACA,I;AACA,qB;AACA,oB;;AAEA,qC;AACA,+D;;AAEA,uC;AACA,wE;AACA,qC;AACA,0C;AACA,a;AACA,K;AACA,+C;;AAEA,oB;AACA,2C;AACA,8B;AACA,S;AACA,wB;AACA,mB;AACA,8B;AACA,sD;AACA,wB;AACA,c;AACA,gE;AACA,O;AACA,K;AACA,uC;;AAEA,gD;AACA,wC;AACA,wB;;AAEA,gF;AACA,uB;AACA,4B;AACA,oB;AACA,8C;AACA,U;AACA,sC;AACA,K;AACA,G;AACA,G;;AAEA,sE;AACA,Y;AACA,E;AACA,oC;AACA,4B;AACA,yB;AACA,gB;AACA,S;AACA,gB;AACA,E;;;;;;;;;;;;;;;;;;;AClLA,sC;AACA,oD;AACA,E;;;;;;;;;;;;;;;;;;;ACFA,iB;;AAEA,kE;AACA,gE;AACA,Y;AACA,E;AACA,8D;AACA,gE;AACA,0D;AACA,mE;AACA,mE;AACA,8D;AACA,E;AACA,4C;AACA,iB;AACA,e;AACA,W;AACA,G;AACA,uC;AACA,2C;AACA,iE;AACA,gD;AACA,sB;AACA,Y;AACA,mE;AACA,wF;AACA,kE;AACA,oD;AACA,wB;;AAEA,qF;AACA,wE;AACA,iF;AACA,8E;AACA,4C;AACA,kD;AACA,+C;AACA,6C;;AAEA,qC;AACA,kF;AACA,Y;AACA,gD;;AAEA,iE;AACA,c;AACA,qE;AACA,sC;AACA,c;AACA,c;AACA,kG;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,iE;AACA,wC;AACA,E;AACA,yC;AACA,oB;AACA,E;;;;;;;;;;;;;;;;;;;AC7DA,uE;;AAEA,kC;;AAEA,iB;;AAEA,0C;AACA,yB;AACA,E;;AAEA,gD;AACA,oB;AACA,uB;AACA,oE;;AAEA,4C;AACA,gD;AACA,I;;AAEA,qC;AACA,uB;AACA,oE;;AAEA,wC;AACA,0C;AACA,uD;;AAEA,yC;AACA,S;AACA,uC;AACA,uB;AACA,e;AACA,uC;AACA,K;;AAEA,e;AACA,G;AACA,G;;AAEA,gE;AACA,wE;AACA,sE;AACA,gE;AACA,E;AACA,4E;AACA,6E;AACA,8E;AACA,wE;AACA,E;AACA,wD;AACA,kE;AACA,0B;AACA,E;AACA,8D;AACA,kE;;AAEA,mB;AACA,oD;;AAEA,qC;AACA,oC;;AAEA,0C;AACA,uD;AACA,W;AACA,mE;AACA,oC;AACA,8D;AACA,0C;AACA,mB;AACA,uB;AACA,iB;AACA,qD;AACA,O;AACA,iB;AACA,M;;AAEA,sB;AACA,kC;AACA,oC;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;ACjFA,2B;AACA,oD;AACA,4D;AACA,yF;AACA,wF;AACA,C;;;;;;;;;;;;;;;;;;;ACLA,+C;AACA,qB;AACA,6C;AACA,mB;AACA,qB;AACA,G;AACA,gC;AACA,2E;;AAEA,4B;AACA,W;AACA,2F;;AAEA,8E;AACA,iF;;AAEA,4C;AACA,e;;AAEA,W;AACA,gB;;AAEA,qE;AACA,kB;AACA,uB;AACA,sD;AACA,wE;AACA,8D;AACA,0C;;AAEA,+B;AACA,4E;;AAEA,a;AACA,E;;AAEA,mD;AACA,wC;AACA,oD;AACA,uC;AACA,iF;;;AAGA,iD;AACA,sD;AACA,gC;AACA,yE;AACA,c;AACA,E","sourcesContent":["Meteor = {\n  isClient: false,\n  isServer: true\n};\n\nMeteor.settings = {};\nif (process.env.METEOR_SETTINGS) {\n  try {\n    Meteor.settings = JSON.parse(process.env.METEOR_SETTINGS);\n  } catch (e) {\n    throw new Error(\"Settings are not valid JSON\");\n  }\n}\n// Push a subset of settings to the client.\nif (Meteor.settings && Meteor.settings.public &&\n    typeof __meteor_runtime_config__ === \"object\") {\n  __meteor_runtime_config__.PUBLIC_SETTINGS = Meteor.settings.public;\n}\n","if (Meteor.isServer)\n  var Future = Npm.require('fibers/future');\n\nif (typeof __meteor_runtime_config__ === 'object' &&\n    __meteor_runtime_config__.meteorRelease)\n  Meteor.release = __meteor_runtime_config__.meteorRelease;\n\n// XXX find a better home for these? Ideally they would be _.get,\n// _.ensure, _.delete..\n\n_.extend(Meteor, {\n  // _get(a,b,c,d) returns a[b][c][d], or else undefined if a[b] or\n  // a[b][c] doesn't exist.\n  //\n  _get: function (obj /*, arguments */) {\n    for (var i = 1; i < arguments.length; i++) {\n      if (!(arguments[i] in obj))\n        return undefined;\n      obj = obj[arguments[i]];\n    }\n    return obj;\n  },\n\n  // _ensure(a,b,c,d) ensures that a[b][c][d] exists. If it does not,\n  // it is created and set to {}. Either way, it is returned.\n  //\n  _ensure: function (obj /*, arguments */) {\n    for (var i = 1; i < arguments.length; i++) {\n      var key = arguments[i];\n      if (!(key in obj))\n        obj[key] = {};\n      obj = obj[key];\n    }\n\n    return obj;\n  },\n\n  // _delete(a, b, c, d) deletes a[b][c][d], then a[b][c] unless it\n  // isn't empty, then a[b] unless it isn't empty.\n  //\n  _delete: function (obj /*, arguments */) {\n    var stack = [obj];\n    var leaf = true;\n    for (var i = 1; i < arguments.length - 1; i++) {\n      var key = arguments[i];\n      if (!(key in obj)) {\n        leaf = false;\n        break;\n      }\n      obj = obj[key];\n      if (typeof obj !== \"object\")\n        break;\n      stack.push(obj);\n    }\n\n    for (var i = stack.length - 1; i >= 0; i--) {\n      var key = arguments[i+1];\n\n      if (leaf)\n        leaf = false;\n      else\n        for (var other in stack[i][key])\n          return; // not empty -- we're done\n\n      delete stack[i][key];\n    }\n  },\n\n  // _wrapAsync can wrap any function that takes some number of arguments that\n  // can't be undefined, followed by some optional arguments, where the callback\n  // is the last optional argument.\n  // e.g. fs.readFile(pathname, [callback]),\n  // fs.open(pathname, flags, [mode], [callback])\n  // For maximum effectiveness and least confusion, wrapAsync should be used on\n  // functions where the callback is the only argument of type Function.\n  //\n  _wrapAsync: function (fn) {\n    return function (/* arguments */) {\n      var self = this;\n      var callback;\n      var fut;\n      var newArgs = _.toArray(arguments);\n\n      var logErr = function (err) {\n        if (err)\n          return Meteor._debug(\"Exception in callback of async function\",\n                               err ? err.stack : err);\n      };\n\n      // Pop off optional args that are undefined\n      while (newArgs.length > 0 &&\n             typeof(newArgs[newArgs.length - 1]) === \"undefined\") {\n        newArgs.pop();\n      }\n      // If we have any left and the last one is a function, then that's our\n      // callback; otherwise, we don't have one.\n      if (newArgs.length > 0 &&\n          newArgs[newArgs.length - 1] instanceof Function) {\n        callback = newArgs.pop();\n      } else {\n        if (Meteor.isClient) {\n          callback = logErr;\n        } else {\n          fut = new Future();\n          callback = fut.resolver();\n        }\n      }\n      newArgs.push(Meteor.bindEnvironment(callback, logErr));\n      var result = fn.apply(self, newArgs);\n      if (fut)\n        return fut.wait();\n      return result;\n    };\n  }\n});\n","// Chooses one of three setImmediate implementations:\n//\n// * Native setImmediate (IE 10, Node 0.9+)\n//\n// * postMessage (many browsers)\n//\n// * setTimeout  (fallback)\n//\n// The postMessage implementation is based on\n// https://github.com/NobleJS/setImmediate/tree/1.0.1\n//\n// Don't use `nextTick` for Node since it runs its callbacks before\n// I/O, which is stricter than we're looking for.\n//\n// Not installed as a polyfill, as our public API is `Meteor.defer`.\n// Since we're not trying to be a polyfill, we have some\n// simplifications:\n//\n// If one invocation of a setImmediate callback pauses itself by a\n// call to alert/prompt/showModelDialog, the NobleJS polyfill\n// implementation ensured that no setImmedate callback would run until\n// the first invocation completed.  While correct per the spec, what it\n// would mean for us in practice is that any reactive updates relying\n// on Meteor.defer would be hung in the main window until the modal\n// dialog was dismissed.  Thus we only ensure that a setImmediate\n// function is called in a later event loop.\n//\n// We don't need to support using a string to be eval'ed for the\n// callback, arguments to the function, or clearImmediate.\n\n\"use strict\";\n\nvar global = this;\n\n\n// IE 10, Node >= 9.1\n\nfunction useSetImmediate() {\n  if (! global.setImmediate)\n    return null;\n  else {\n    var setImmediate = function (fn) {\n      global.setImmediate(fn);\n    };\n    setImmediate.implementation = 'setImmediate';\n    return setImmediate;\n  }\n}\n\n\n// Android 2.3.6, Chrome 26, Firefox 20, IE 8-9, iOS 5.1.1 Safari\n\nfunction usePostMessage() {\n  // The test against `importScripts` prevents this implementation\n  // from being installed inside a web worker, where\n  // `global.postMessage` means something completely different and\n  // can't be used for this purpose.\n\n  if (!global.postMessage || global.importScripts) {\n    return null;\n  }\n\n  // Avoid synchronous post message implementations.\n\n  var postMessageIsAsynchronous = true;\n  var oldOnMessage = global.onmessage;\n  global.onmessage = function () {\n      postMessageIsAsynchronous = false;\n  };\n  global.postMessage(\"\", \"*\");\n  global.onmessage = oldOnMessage;\n\n  if (! postMessageIsAsynchronous)\n    return null;\n\n  var funcIndex = 0;\n  var funcs = {};\n\n  // Installs an event handler on `global` for the `message` event: see\n  // * https://developer.mozilla.org/en/DOM/window.postMessage\n  // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n  // XXX use Random.id() here?\n  var MESSAGE_PREFIX = \"Meteor._setImmediate.\" + Math.random() + '.';\n\n  function isStringAndStartsWith(string, putativeStart) {\n    return (typeof string === \"string\" &&\n            string.substring(0, putativeStart.length) === putativeStart);\n  }\n\n  function onGlobalMessage(event) {\n    // This will catch all incoming messages (even from other\n    // windows!), so we need to try reasonably hard to avoid letting\n    // anyone else trick us into firing off. We test the origin is\n    // still this window, and that a (randomly generated)\n    // unpredictable identifying prefix is present.\n    if (event.source === global &&\n        isStringAndStartsWith(event.data, MESSAGE_PREFIX)) {\n      var index = event.data.substring(MESSAGE_PREFIX.length);\n      try {\n        if (funcs[index])\n          funcs[index]();\n      }\n      finally {\n        delete funcs[index];\n      }\n    }\n  }\n\n  if (global.addEventListener) {\n    global.addEventListener(\"message\", onGlobalMessage, false);\n  } else {\n    global.attachEvent(\"onmessage\", onGlobalMessage);\n  }\n\n  var setImmediate = function (fn) {\n    // Make `global` post a message to itself with the handle and\n    // identifying prefix, thus asynchronously invoking our\n    // onGlobalMessage listener above.\n    ++funcIndex;\n    funcs[funcIndex] = fn;\n    global.postMessage(MESSAGE_PREFIX + funcIndex, \"*\");\n  };\n  setImmediate.implementation = 'postMessage';\n  return setImmediate;\n}\n\n\nfunction useTimeout() {\n  var setImmediate = function (fn) {\n    global.setTimeout(fn, 0);\n  };\n  setImmediate.implementation = 'setTimeout';\n  return setImmediate;\n}\n\n\nMeteor._setImmediate =\n  useSetImmediate() ||\n  usePostMessage() ||\n  useTimeout();\n","var withoutInvocation = function (f) {\n  if (Package.livedata) {\n    var _CurrentInvocation = Package.livedata.DDP._CurrentInvocation;\n    if (_CurrentInvocation.get() && _CurrentInvocation.get().isSimulation)\n      throw new Error(\"Can't set timers inside simulations\");\n    return function () { _CurrentInvocation.withValue(null, f); };\n  }\n  else\n    return f;\n};\n\nvar bindAndCatch = function (context, f) {\n  return Meteor.bindEnvironment(withoutInvocation(f), function (e) {\n    // XXX report nicely (or, should we catch it at all?)\n    Meteor._debug(\"Exception from \" + context + \":\", e, e.stack);\n  });\n};\n\n_.extend(Meteor, {\n  // Meteor.setTimeout and Meteor.setInterval callbacks scheduled\n  // inside a server method are not part of the method invocation and\n  // should clear out the CurrentInvocation environment variable.\n\n  setTimeout: function (f, duration) {\n    return setTimeout(bindAndCatch(\"setTimeout callback\", f), duration);\n  },\n\n  setInterval: function (f, duration) {\n    return setInterval(bindAndCatch(\"setInterval callback\", f), duration);\n  },\n\n  clearInterval: function(x) {\n    return clearInterval(x);\n  },\n\n  clearTimeout: function(x) {\n    return clearTimeout(x);\n  },\n\n  // XXX consider making this guarantee ordering of defer'd callbacks, like\n  // Deps.afterFlush or Node's nextTick (in practice). Then tests can do:\n  //    callSomethingThatDefersSomeWork();\n  //    Meteor.defer(expect(somethingThatValidatesThatTheWorkHappened));\n  defer: function (f) {\n    Meteor._setImmediate(bindAndCatch(\"defer callback\", f));\n  }\n});\n","// http://davidshariff.com/blog/javascript-inheritance-patterns/\nvar inherits = function (child, parent) {\n  var tmp = function () {};\n  tmp.prototype = parent.prototype;\n  child.prototype = new tmp;\n  child.prototype.constructor = child;\n};\n\n// Makes an error subclass which properly contains a stack trace in most\n// environments. constructor can set fields on `this` (and should probably set\n// `message`, which is what gets displayed at the top of a stack trace).\n//\nMeteor.makeErrorType = function (name, constructor) {\n  var errorClass = function (/*arguments*/) {\n    var self = this;\n\n    // Ensure we get a proper stack trace in most Javascript environments\n    if (Error.captureStackTrace) {\n      // V8 environments (Chrome and Node.js)\n      Error.captureStackTrace(self, errorClass);\n    } else {\n      // Firefox\n      var e = new Error;\n      e.__proto__ = errorClass.prototype;\n      if (e instanceof errorClass)\n        self = e;\n    }\n    // Safari magically works.\n\n    constructor.apply(self, arguments);\n\n    self.errorType = name;\n\n    return self;\n  };\n\n  inherits(errorClass, Error);\n\n  return errorClass;\n};\n\n// This should probably be in the livedata package, but we don't want\n// to require you to use the livedata package to get it. Eventually we\n// should probably rename it to DDP.Error and put it back in the\n// 'livedata' package (which we should rename to 'ddp' also.)\n//\n// Note: The DDP server assumes that Meteor.Error EJSON-serializes as an object\n// containing 'error' and optionally 'reason' and 'details'.\n// The DDP client manually puts these into Meteor.Error objects. (We don't use\n// EJSON.addType here because the type is determined by location in the\n// protocol, not text on the wire.)\n//\nMeteor.Error = Meteor.makeErrorType(\n  \"Meteor.Error\",\n  function (error, reason, details) {\n    var self = this;\n\n    // Currently, a numeric code, likely similar to a HTTP code (eg,\n    // 404, 500). That is likely to change though.\n    self.error = error;\n\n    // Optional: A short human-readable summary of the error. Not\n    // intended to be shown to end users, just developers. (\"Not Found\",\n    // \"Internal Server Error\")\n    self.reason = reason;\n\n    // Optional: Additional information about the error, say for\n    // debugging. It might be a (textual) stack trace if the server is\n    // willing to provide one. The corresponding thing in HTTP would be\n    // the body of a 404 or 500 response. (The difference is that we\n    // never expect this to be shown to end users, only developers, so\n    // it doesn't need to be pretty.)\n    self.details = details;\n\n    // This is what gets displayed at the top of a stack trace. Current\n    // format is \"[404]\" (if no reason is set) or \"File not found [404]\"\n    if (self.reason)\n      self.message = self.reason + ' [' + self.error + ']';\n    else\n      self.message = '[' + self.error + ']';\n  });\n","var path = Npm.require('path');\nvar Fiber = Npm.require('fibers');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\nMeteor._noYieldsAllowed = function (f) {\n  // \"Fiber\" and \"yield\" are both in the global namespace. The yield function is\n  // at both \"yield\" and \"Fiber.yield\". (It's also at require('fibers').yield\n  // but that is because require('fibers') === Fiber.)\n  var savedYield = Fiber.yield;\n  Fiber.yield = function () {\n    throw new Error(\"Can't call yield in a noYieldsAllowed block!\");\n  };\n  global.yield = Fiber.yield;\n  try {\n    return f();\n  } finally {\n    Fiber.yield = savedYield;\n    global.yield = savedYield;\n  }\n};\n\n// Meteor._SynchronousQueue is a queue which runs task functions serially.\n// Tasks are assumed to be synchronous: ie, it's assumed that they are\n// done when they return.\n//\n// It has two methods:\n//   - queueTask queues a task to be run, and returns immediately.\n//   - runTask queues a task to be run, and then yields. It returns\n//     when the task finishes running.\n//\n// It's safe to call queueTask from within a task, but not runTask (unless\n// you're calling runTask from a nested Fiber).\n//\n// Somewhat inspired by async.queue, but specific to blocking tasks.\n// XXX break this out into an NPM module?\n// XXX could maybe use the npm 'schlock' module instead, which would\n//     also support multiple concurrent \"read\" tasks\n//\nMeteor._SynchronousQueue = function () {\n  var self = this;\n  // List of tasks to run (not including a currently-running task if any). Each\n  // is an object with field 'task' (the task function to run) and 'future' (the\n  // Future associated with the blocking runTask call that queued it, or null if\n  // called from queueTask).\n  self._taskHandles = [];\n  // This is true if self._run() is either currently executing or scheduled to\n  // do so soon.\n  self._runningOrRunScheduled = false;\n  // During the execution of a task, this is set to the fiber used to execute\n  // that task. We use this to throw an error rather than deadlocking if the\n  // user calls runTask from within a task on the same fiber.\n  self._currentTaskFiber = undefined;\n  // This is true if we're currently draining.  While we're draining, a further\n  // drain is a noop, to prevent infinite loops.  \"drain\" is a heuristic type\n  // operation, that has a meaning like unto \"what a naive person would expect\n  // when modifying a table from an observe\"\n  self._draining = false;\n};\n\n_.extend(Meteor._SynchronousQueue.prototype, {\n  runTask: function (task) {\n    var self = this;\n\n    if (!self.safeToRunTask()) {\n      if (Fiber.current)\n        throw new Error(\"Can't runTask from another task in the same fiber\");\n      else\n        throw new Error(\"Can only call runTask in a Fiber\");\n    }\n\n    var fut = new Future;\n    self._taskHandles.push({task: Meteor.bindEnvironment(task, function (e) {\n      Meteor._debug(\"Exception from task:\", e ? e.stack : e);\n      throw e;\n    }), future: fut});\n    self._scheduleRun();\n    // Yield. We'll get back here after the task is run (and will throw if the\n    // task throws).\n    fut.wait();\n  },\n  queueTask: function (task) {\n    var self = this;\n    self._taskHandles.push({task: task});\n    self._scheduleRun();\n    // No need to block.\n  },\n\n  flush: function () {\n    var self = this;\n    self.runTask(function () {});\n  },\n\n  safeToRunTask: function () {\n    var self = this;\n    return Fiber.current && self._currentTaskFiber !== Fiber.current;\n  },\n\n  drain: function () {\n    var self = this;\n    if (self._draining)\n      return;\n    if (!self.safeToRunTask())\n      return;\n    self._draining = true;\n    while (!_.isEmpty(self._taskHandles)) {\n      self.flush();\n    }\n    self._draining = false;\n  },\n\n  _scheduleRun: function () {\n    var self = this;\n\n    // Already running or scheduled? Do nothing.\n    if (self._runningOrRunScheduled)\n      return;\n\n    self._runningOrRunScheduled = true;\n\n    process.nextTick(function () {\n      Fiber(function () {\n        self._run();\n      }).run();\n    });\n  },\n  _run: function () {\n    var self = this;\n\n    if (!self._runningOrRunScheduled)\n      throw new Error(\"expected to be _runningOrRunScheduled\");\n\n    if (_.isEmpty(self._taskHandles)) {\n      // Done running tasks! Don't immediately schedule another run, but\n      // allow future tasks to do so.\n      self._runningOrRunScheduled = false;\n      return;\n    }\n    var taskHandle = self._taskHandles.shift();\n\n    // Run the task.\n    self._currentTaskFiber = Fiber.current;\n    var exception = undefined;\n    try {\n      taskHandle.task();\n    } catch (err) {\n      if (taskHandle.future) {\n        // We'll throw this exception through runTask.\n        exception = err;\n      } else {\n        Meteor._debug(\"Exception in queued task: \" + err.stack);\n      }\n    }\n    self._currentTaskFiber = undefined;\n\n    // Soon, run the next task, if there is any.\n    self._runningOrRunScheduled = false;\n    self._scheduleRun();\n\n    // If this was queued with runTask, let the runTask call return (throwing if\n    // the task threw).\n    if (taskHandle.future) {\n      if (exception)\n        taskHandle.future['throw'](exception);\n      else\n        taskHandle.future['return']();\n    }\n  }\n});\n\n// Sleep. Mostly used for debugging (eg, inserting latency into server\n// methods).\n//\nMeteor._sleepForMs = function (ms) {\n  var fiber = Fiber.current;\n  setTimeout(function() {\n    fiber.run();\n  }, ms);\n  Fiber.yield();\n};\n","Meteor.startup = function (callback) {\n  __meteor_bootstrap__.startup_hooks.push(callback);\n};\n","var suppress = 0;\n\n// replacement for console.log. This is a temporary API. We should\n// provide a real logging API soon (possibly just a polyfill for\n// console?)\n//\n// NOTE: this is used on the server to print the warning about\n// having autopublish enabled when you probably meant to turn it\n// off. it's not really the proper use of something called\n// _debug. the intent is for this message to go to the terminal and\n// be very visible. if you change _debug to go someplace else, etc,\n// please fix the autopublish code to do something reasonable.\n//\nMeteor._debug = function (/* arguments */) {\n  if (suppress) {\n    suppress--;\n    return;\n  }\n  if (typeof console !== 'undefined' &&\n      typeof console.log !== 'undefined') {\n    if (arguments.length == 0) { // IE Companion breaks otherwise\n      // IE10 PP4 requires at least one argument\n      console.log('');\n    } else {\n      // IE doesn't have console.log.apply, it's not a real Object.\n      // http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9\n      // http://patik.com/blog/complete-cross-browser-console-log/\n      if (typeof console.log.apply === \"function\") {\n        // Most browsers\n\n        // Chrome and Safari only hyperlink URLs to source files in first argument of\n        // console.log, so try to call it with one argument if possible.\n        // Approach taken here: If all arguments are strings, join them on space.\n        // See https://github.com/meteor/meteor/pull/732#issuecomment-13975991\n        var allArgumentsOfTypeString = true;\n        for (var i = 0; i < arguments.length; i++)\n          if (typeof arguments[i] !== \"string\")\n            allArgumentsOfTypeString = false;\n\n        if (allArgumentsOfTypeString)\n          console.log.apply(console, [Array.prototype.join.call(arguments, \" \")]);\n        else\n          console.log.apply(console, arguments);\n\n      } else if (typeof Function.prototype.bind === \"function\") {\n        // IE9\n        var log = Function.prototype.bind.call(console.log, console);\n        log.apply(console, arguments);\n      } else {\n        // IE8\n        Function.prototype.call.call(console.log, console, Array.prototype.slice.call(arguments));\n      }\n    }\n  }\n};\n\n// Suppress the next 'count' Meteor._debug messsages. Use this to\n// stop tests from spamming the console.\n//\nMeteor._suppress_log = function (count) {\n  suppress += count;\n};\n","// Fiber-aware implementation of dynamic scoping, for use on the server\n\nvar Fiber = Npm.require('fibers');\n\nvar nextSlot = 0;\n\nMeteor.EnvironmentVariable = function () {\n  this.slot = nextSlot++;\n};\n\n_.extend(Meteor.EnvironmentVariable.prototype, {\n  get: function () {\n    if (!Fiber.current)\n      throw new Error(\"Meteor code must always run within a Fiber\");\n\n    return Fiber.current._meteor_dynamics &&\n      Fiber.current._meteor_dynamics[this.slot];\n  },\n\n  withValue: function (value, func) {\n    if (!Fiber.current)\n      throw new Error(\"Meteor code must always run within a Fiber\");\n\n    if (!Fiber.current._meteor_dynamics)\n      Fiber.current._meteor_dynamics = [];\n    var currentValues = Fiber.current._meteor_dynamics;\n\n    var saved = currentValues[this.slot];\n    try {\n      currentValues[this.slot] = value;\n      var ret = func();\n    } finally {\n      currentValues[this.slot] = saved;\n    }\n\n    return ret;\n  }\n});\n\n// Meteor application code is always supposed to be run inside a\n// fiber. bindEnvironment ensures that the function it wraps is run from\n// inside a fiber and ensures it sees the values of Meteor environment\n// variables that are set at the time bindEnvironment is called.\n//\n// If an environment-bound function is called from outside a fiber (eg, from\n// an asynchronous callback from a non-Meteor library such as MongoDB), it'll\n// kick off a new fiber to execute the function, and returns undefined as soon\n// as that fiber returns or yields (and func's return value is ignored).\n//\n// If it's called inside a fiber, it works normally (the\n// return value of the function will be passed through, and no new\n// fiber will be created.)\n//\nMeteor.bindEnvironment = function (func, onException, _this) {\n  var boundValues = _.clone(Fiber.current._meteor_dynamics || []);\n\n  if (!onException)\n    throw new Error(\"onException must be supplied\");\n\n  return function (/* arguments */) {\n    var args = _.toArray(arguments);\n\n    var runWithEnvironment = function () {\n      var savedValues = Fiber.current._meteor_dynamics;\n      try {\n        // Need to clone boundValues in case two fibers invoke this\n        // function at the same time\n        Fiber.current._meteor_dynamics = _.clone(boundValues);\n        var ret = func.apply(_this, args);\n      } catch (e) {\n        onException(e);\n      } finally {\n        Fiber.current._meteor_dynamics = savedValues;\n      }\n      return ret;\n    };\n\n    if (Fiber.current)\n      return runWithEnvironment();\n    Fiber(runWithEnvironment).run();\n  };\n};\n","if (process.env.ROOT_URL &&\n    typeof __meteor_runtime_config__ === \"object\") {\n  __meteor_runtime_config__.ROOT_URL = process.env.ROOT_URL;\n  var pathPrefix = Npm.require('url').parse(__meteor_runtime_config__.ROOT_URL).pathname;\n  __meteor_runtime_config__.ROOT_URL_PATH_PREFIX = pathPrefix === \"/\" ? \"\" : pathPrefix;\n}\n","Meteor.absoluteUrl = function (path, options) {\n  // path is optional\n  if (!options && typeof path === 'object') {\n    options = path;\n    path = undefined;\n  }\n  // merge options with defaults\n  options = _.extend({}, Meteor.absoluteUrl.defaultOptions, options || {});\n\n  var url = options.rootUrl;\n  if (!url)\n    throw new Error(\"Must pass options.rootUrl or set ROOT_URL in the server environment\");\n\n  if (!/^http[s]?:\\/\\//i.test(url)) // url starts with 'http://' or 'https://'\n    url = 'http://' + url; // we will later fix to https if options.secure is set\n\n  if (!/\\/$/.test(url)) // url ends with '/'\n    url += '/';\n\n  if (path)\n    url += path;\n\n  // turn http to http if secure option is set, and we're not talking\n  // to localhost.\n  if (options.secure &&\n      /^http:/.test(url) && // url starts with 'http:'\n      !/http:\\/\\/localhost[:\\/]/.test(url) && // doesn't match localhost\n      !/http:\\/\\/127\\.0\\.0\\.1[:\\/]/.test(url)) // or 127.0.0.1\n    url = url.replace(/^http:/, 'https:');\n\n  if (options.replaceLocalhost)\n    url = url.replace(/^http:\\/\\/localhost([:\\/].*)/, 'http://127.0.0.1$1');\n\n  return url;\n};\n\n// allow later packages to override default options\nMeteor.absoluteUrl.defaultOptions = { };\nif (typeof __meteor_runtime_config__ === \"object\" &&\n    __meteor_runtime_config__.ROOT_URL)\n  Meteor.absoluteUrl.defaultOptions.rootUrl = __meteor_runtime_config__.ROOT_URL;\n\n\nMeteor._relativeToSiteRootUrl = function (link) {\n  if (typeof __meteor_runtime_config__ === \"object\" &&\n      link.substr(0, 1) === \"/\")\n    link = (__meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\") + link;\n  return link;\n};\n"]}